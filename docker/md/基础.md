## 简介
<font style="color:rgb(51, 51, 51);">Docker 是一个开源的应用容器引擎，基于 </font>[Go 语言](https://www.runoob.com/go/go-tutorial.html)<font style="color:rgb(51, 51, 51);"> 并遵从 Apache2.0 协议开源。</font>

<font style="color:rgb(51, 51, 51);">Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</font>

<font style="color:rgb(51, 51, 51);">容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</font>

<font style="color:rgb(51, 51, 51);">Docker 官网：</font>[https://www.docker.com](https://www.docker.com/)

<font style="color:rgb(51, 51, 51);">Github Docker 源码：</font>[https://github.com/docker/docker-ce](https://github.com/docker/docker-ce)

## 相关
文档  [官方文档](https://docs.docker.com/)  [中文文档-1](https://docker.it-docs.cn/)  [中文文档-2](https://docker.cadn.net.cn/)

## Docker镜像
将docker修改为国内镜像源 ， 在/etc/docker/daemon.json文件中添加下面参数

```yaml
vim /etc/docker/daemon.json
# 添加 #中国科技大学的docker镜像源
{
 "registry-mirrors" : ["https://docker.mirrors.ustc.edu.cn"] 
}

# 添加多个
"registry-mirrors": [
  "https://registry.docker-cn.com",
  "https://docker.mirrors.ustc.edu.cn",
  "http://hub-mirror.c.163.com"
  "https://4aecwtdf.mirror.aliyuncs.com",
  "https://dockerhub.azk8s.cn",
  "https://docker.m.daocloud.io",
  "https://docker.mirrors.sjtug.sjtu.edu.cn",
  "https://mirror.iscas.ac.cn",
  "https://registry.cn-hangzhou.aliyuncs.com",
  "https://noohub.ru",
  "https://dockerproxy.com",
  "https://docker.nju.edu.cn",
  "https://dockercf.jsdelivr.fyi",
  "https://docker.jsdelivr.fyi",
  "https://dockertest.jsdelivr.fyi"
]
```

重启docker

```bash
systemctl daemon-reload
systemctl restart docker
```

## <font style="color:rgb(51, 51, 51);">Docker的应用场景</font>
Docker 的主要用途，目前有三大类。

（1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。

（2）提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。

（3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。



+ <font style="color:rgb(51, 51, 51);">Web 应用的自动化打包和发布。</font>
+ <font style="color:rgb(51, 51, 51);">自动化测试和持续集成、发布。</font>
+ <font style="color:rgb(51, 51, 51);">在服务型环境中部署和调整数据库或其他的后台应用。</font>
+ <font style="color:rgb(51, 51, 51);">从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</font>

## <font style="color:rgb(51, 51, 51);">Docker 的优点</font>
<font style="color:rgb(51, 51, 51);">Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</font>

## <font style="color:rgb(0, 0, 0);">Docker 架构</font>
<font style="color:rgb(51, 51, 51);">Docker 包括三个基本概念:</font>

+ **<font style="color:rgb(51, 51, 51);">镜像（Image）</font>**<font style="color:rgb(51, 51, 51);">：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</font>
+ **<font style="color:rgb(51, 51, 51);">容器（Container）</font>**<font style="color:rgb(51, 51, 51);">：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</font>
+ **<font style="color:rgb(51, 51, 51);">仓库（Repository）</font>**<font style="color:rgb(51, 51, 51);">：仓库可看成一个代码控制中心，用来保存镜像。</font>

## <font style="color:rgb(0, 0, 0);">CentOS Docker 安装</font>
```plain
#安装所需的软件包
sudo yum install -y yum-utils \
  device-mapper-persistent-data \
  lvm2
  
#设置仓库 阿里云
sudo yum-config-manager \
    --add-repo \
    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

#选择docker版本并安装
#(1)列出并排序您存储库中可用的版本。此示例按版本号（从高到低）对结果进行排序。
yum list docker-ce --showduplicates | sort -r
#（2）选择一个版本并安装：yum install docker-ce-版本号
yum -y install docker-ce-20.10.9

#启动docker
systemctl start docker

#如果想添加到开机启动
sudo systemctl enable docker

#通过运行 hello-world 映像来验证是否正确安装了 Docker Engine-Community
sudo docker run hello-world
```

## <font style="color:rgb(0, 0, 0);">CentOS Docker 卸载</font>
更新

<font style="color:rgb(0, 134, 179);">sudo </font>yum update docker-ce-20.10.9

<font style="color:rgb(51, 51, 51);">删除安装包：</font>

<font style="color:rgb(0, 0, 0);">yum remove </font>docker-ce-20.10.9

<font style="color:rgb(51, 51, 51);">删除镜像、容器、配置文件等内容：</font>

<font style="color:rgb(0, 0, 0);">rm </font><font style="color:rgb(102, 102, 0);">-</font><font style="color:rgb(0, 0, 0);">rf </font><font style="color:rgb(102, 102, 0);">/</font><font style="color:rgb(0, 0, 136);">var</font><font style="color:rgb(102, 102, 0);">/</font><font style="color:rgb(0, 0, 0);">lib</font><font style="color:rgb(102, 102, 0);">/</font><font style="color:rgb(0, 0, 0);">docker</font>

## <font style="color:rgb(0, 0, 0);">Docker Hello World</font>
### <font style="color:rgb(51, 51, 51);"> docker run</font>
<font style="color:rgb(51, 51, 51);">Docker 允许你在容器内运行应用程序， 使用 </font>**<font style="color:rgb(51, 51, 51);">docker run</font>**<font style="color:rgb(51, 51, 51);"> 命令来在容器内运行一个应用程序。</font>

```plain
docker run ubuntu:15.10 /bin/echo "Hello world"
```

<font style="color:rgb(51, 51, 51);">输出Hello world</font>

<font style="color:rgb(51, 51, 51);">各个参数解析：</font>

+ **<font style="color:rgb(51, 51, 51);">docker:</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">Docker 的二进制执行文件。</font>
+ **<font style="color:rgb(51, 51, 51);">run:</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">与前面的 docker 组合来运行一个容器。</font>
+ **<font style="color:rgb(51, 51, 51);">ubuntu:15.10</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</font>
+ **<font style="color:rgb(51, 51, 51);">/bin/echo "Hello world": </font>**<font style="color:rgb(51, 51, 51);">在启动的容器里执行的命令</font>

### <font style="color:rgb(51, 51, 51);">运行交互式的容器</font>
```plain
docker run -i -t ubuntu:15.10 /bin/bash
```

<font style="color:rgb(51, 51, 51);">各个参数解析：</font>

+ **<font style="color:rgb(51, 51, 51);">-t:</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">在新容器内指定一个伪终端或终端。</font>
+ **<font style="color:rgb(51, 51, 51);">-i:</font>**<font style="color:rgb(51, 51, 51);"> 允许你对容器内的标准输入 (STDIN) 进行交互。</font>

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651066745861-eef78cfd-dad0-43d0-90dd-2debbd31a488.png)

<font style="color:rgb(51, 51, 51);">注意第二行 </font>**<font style="color:rgb(51, 51, 51);background-color:rgb(236, 234, 230);">root@</font>**c27e1f551360**<font style="color:rgb(51, 51, 51);background-color:rgb(236, 234, 230);">:/#</font>**<font style="color:rgb(51, 51, 51);">，此时我们已进入一个 ubuntu15.10 系统的容器</font>

<font style="color:rgb(51, 51, 51);">我们尝试在容器中运行命令</font>**<font style="color:rgb(51, 51, 51);"> cat /proc/version</font>**<font style="color:rgb(51, 51, 51);">和</font>**<font style="color:rgb(51, 51, 51);">ls</font>**<font style="color:rgb(51, 51, 51);">分别查看当前系统的版本信息和当前目录下的文件列表</font>

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651066879979-9482646d-a036-4511-8b5a-5abcb7cc9bff.png)

<font style="color:rgb(51, 51, 51);">我们可以通过运行 exit 命令或者使用 CTRL+D 来退出容器。</font>

### <font style="color:rgb(51, 51, 51);">启动容器（后台模式）</font>


<font style="color:rgb(51, 51, 51);">使用以下命令创建一个以进程方式运行的容器</font>

```plain
[root@VM-16-16-centos lighthouse]# docker run -d ubuntu:15.10 /bin/sh -c "while true; do echo hello world; sleep 1; done"
56d4c69dacbe2e2dd1a18149ba3b05b0324a545523ca371858f24c5e88bfce81
[root@VM-16-16-centos lighthouse]# 
```

<font style="color:rgb(51, 51, 51);">在输出中，我们没有看到期望的 "hello world"，而是一串长字符</font>

56d4c69dacbe2e2dd1a18149ba3b05b0324a545523ca371858f24c5e88bfce81

<font style="color:rgb(51, 51, 51);">这个长字符串叫做容器 ID，对每个容器来说都是唯一的，我们可以通过容器 ID 来查看对应的容器发生了什么。</font>

<font style="color:rgb(51, 51, 51);">首先，我们需要确认容器有在运行，可以通过 </font>**<font style="color:rgb(51, 51, 51);">docker ps</font>**<font style="color:rgb(51, 51, 51);"> 来查看：</font>

```plain
[root@VM-16-16-centos lighthouse]# docker ps
CONTAINER ID   IMAGE          COMMAND                  CREATED              STATUS          PORTS     NAMES
56d4c69dacbe   ubuntu:15.10   "/bin/sh -c 'while t…"   About a minute ago   Up 59 seconds             magical_mclean
```

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651067034532-e2074e31-2b06-46cb-9131-df9ae5ac30c7.png)

<font style="color:rgb(51, 51, 51);">输出详情介绍：</font>

**<font style="color:rgb(51, 51, 51);">CONTAINER ID:</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">容器 ID。</font>

**<font style="color:rgb(51, 51, 51);">IMAGE:</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">使用的镜像。</font>

**<font style="color:rgb(51, 51, 51);">COMMAND:</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">启动容器时运行的命令。</font>

**<font style="color:rgb(51, 51, 51);">CREATED:</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">容器的创建时间。</font>

**<font style="color:rgb(51, 51, 51);">STATUS:</font>**<font style="color:rgb(51, 51, 51);"> 容器状态。</font>

**<font style="color:rgb(51, 51, 51);">PORTS:</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">容器的端口信息和使用的连接类型（tcp\udp）。</font>

**<font style="color:rgb(51, 51, 51);">NAMES:</font>**<font style="color:rgb(51, 51, 51);"> 自动分配的容器名称。</font>

<font style="color:rgb(51, 51, 51);">状态有7种：</font>

+ <font style="color:rgb(51, 51, 51);">created（已创建）</font>
+ <font style="color:rgb(51, 51, 51);">restarting（重启中）</font>
+ <font style="color:rgb(51, 51, 51);">running 或 Up（运行中）</font>
+ <font style="color:rgb(51, 51, 51);">removing（迁移中）</font>
+ <font style="color:rgb(51, 51, 51);">paused（暂停）</font>
+ <font style="color:rgb(51, 51, 51);">exited（停止）</font>
+ <font style="color:rgb(51, 51, 51);">dead（死亡）</font>

### <font style="color:rgb(51, 51, 51);">查看容器（运行）</font>
```plain
docker ps
#查看所有容器
docker ps -a

```

### <font style="color:rgb(51, 51, 51);">查看容器（输出）</font>
<font style="color:rgb(51, 51, 51);">在宿主主机内使用 </font>**<font style="color:rgb(51, 51, 51);background-color:rgb(236, 234, 230);">docker logs</font>**<font style="color:rgb(51, 51, 51);"> 命令，查看容器内的标准输出：</font>

```plain
docker logs 56d4c69dacbe
```

### <font style="color:rgb(51, 51, 51);">停止容器</font>
```plain
docker stop 56d4c69dacbe
#停止之后查看
docker ps
#查看最后一次创建的容器
docker ps -l 
#指定 （ID 或者名字）容器的某个确定端口映射到宿主机的端口号
docker stop bf08b7f2cd89  #指定id
docker stop wizardly_chandrasekhar  #指定docker_name
```

## <font style="color:rgb(79, 79, 79);">Docker服务重启</font>
```plain
systemctl restart docker
```

## <font style="color:rgb(79, 79, 79);">Docker加速</font>
```plain
curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://4e70ba5d.m.daocloud.io
#查看镜像
cat /etc/docker/daemon.json 
#输入以下 {"registry-mirrors": ["http://4e70ba5d.m.daocloud.io"]}

#或者使用阿里云，进入虚拟机修改docker配置（建议使用）
vim /etc/docker/daemon.json
#修改以下 
{ "registry-mirrors": ["https://nsodgxr5.mirror.aliyuncs.com"] }

#重启docker服务
sudo systemctl restart docker
```

## <font style="color:rgb(0, 0, 0);">Docker 容器使用</font>
### <font style="color:rgb(51, 51, 51);">Docker 客户端</font>
```plain
# docker 命令来查看到 Docker 客户端的所有命令选项
docker
#更深入的了解指定的 Docker 命令使用方法 docker command --help  ，例如
docker stats --help


```

### <font style="color:rgb(51, 51, 51);">容器使用</font>
### <font style="color:rgb(51, 51, 51);">获取（载入）镜像</font>
<font style="color:rgb(51, 51, 51);">如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：</font>

```plain
docker pull ubuntu
```

### <font style="color:rgb(51, 51, 51);">启动容器</font>
<font style="color:rgb(51, 51, 51);">以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：</font>

```plain
 docker run -it ubuntu /bin/bash
```

<font style="color:rgb(51, 51, 51);">参数说明：</font>

+ **<font style="color:rgb(51, 51, 51);">-i</font>**<font style="color:rgb(51, 51, 51);">: 交互式操作。</font>
+ **<font style="color:rgb(51, 51, 51);">-t</font>**<font style="color:rgb(51, 51, 51);">: 终端。</font>
+ **<font style="color:rgb(51, 51, 51);">ubuntu</font>**<font style="color:rgb(51, 51, 51);">: ubuntu 镜像。</font>
+ **<font style="color:rgb(51, 51, 51);">/bin/bash</font>**<font style="color:rgb(51, 51, 51);">：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</font>

### <font style="color:rgb(51, 51, 51);">启动已停止运行的容器</font>
```plain
#查看所有的容器命令如
docker ps -a
#启动一个结束的docker
docker start e1bd25c91255
```

### <font style="color:rgb(51, 51, 51);">后台运行</font>
<font style="color:rgb(51, 51, 51);">在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 </font>**<font style="color:rgb(51, 51, 51);background-color:rgb(236, 234, 230);">-d</font>**<font style="color:rgb(51, 51, 51);"> 指定容器的运行模式。</font>

<font style="color:rgb(51, 51, 51);">容器名字为 </font>ubuntu-test

```plain
docker run -itd --name ubuntu-test ubuntu /bin/bash
```

### <font style="color:rgb(51, 51, 51);">停止一个容器</font>
```plain
docker stop e1bd25c91255
```

### <font style="color:rgb(51, 51, 51);">重启（启动）一个容器</font>
```plain
#启动一个停止的容器
docker start e1bd25c91255
#重启一个容器
docker restart e1bd25c91255
```

### <font style="color:rgb(51, 51, 51);">进入容器（-d）</font>
<font style="color:rgb(51, 51, 51);">在使用 </font>**<font style="color:rgb(51, 51, 51);">-d</font>**<font style="color:rgb(51, 51, 51);"> 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</font>

+ **<font style="color:rgb(51, 51, 51);">docker attach</font>**
+ **<font style="color:rgb(51, 51, 51);">docker exec</font>**<font style="color:rgb(51, 51, 51);">：推荐大家使用 docker exec 命令，因为此命令会退出容器终端，但不会导致容器的停止。</font>

```plain
#如果从这个容器退出，会导致容器的停止
docker attach e1bd25c91255

# 如果从这个容器退出，容器不会停止，更多参数说明请使用 docker exec --help 命令查看。
docker exec -it e1bd25c91255 /bin/bash
```

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651070115069-5c0859e9-a46c-4faa-8233-3c63823b0882.png)

### <font style="color:rgb(51, 51, 51);">导出容器</font>
<font style="color:rgb(51, 51, 51);">如果要导出本地某个容器，可以使用 </font>**<font style="color:rgb(51, 51, 51);">docker export</font>**<font style="color:rgb(51, 51, 51);"> 命令，</font><font style="color:rgb(77, 77, 77);">导出为一个tar包</font>

<font style="color:rgb(51, 51, 51);">导出容器 1e560fca3906 快照到本地文件 ubuntu.tar，目录为 /homt/用户角色</font>

```plain
docker export e1bd25c91255 > ubuntu.tar
```

### <font style="color:rgb(51, 51, 51);">导入容器快照</font>
**<font style="color:rgb(51, 51, 51);">方式1：导入本地快照文件</font>**

<font style="color:rgb(51, 51, 51);">可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1:</font>

```plain
 cat /home/lighthouse/ubuntu.tar | docker import - test/ubuntu:v1
 #查看快照
 docker images
```

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651070699187-53fd2038-c942-4f9b-a0e6-f34caeb9d65f.png)

**<font style="color:rgb(51, 51, 51);">方式2：</font>**<font style="color:rgb(51, 51, 51);">通过指定 URL 或者某个目录来导入</font>

```plain
docker import http://example.com/exampleimage.tgz example/imagerepo
```

### <font style="color:rgb(51, 51, 51);">删除容器</font>
<font style="color:rgb(51, 51, 51);">删除容器使用 </font>**<font style="color:rgb(51, 51, 51);">docker rm</font>**<font style="color:rgb(51, 51, 51);"> 命令：</font>

```plain
docker rm -f 1e560fca3906
```

<font style="color:rgb(51, 51, 51);">删除所有容器</font>

```json
#首先需要停止所有的容器
docker stop $(docker ps -a -q)
#删除所有的容器(只删除单个时把后面的变量改为container id即可)
docker rm $(docker ps -a -q)
```

<font style="color:rgb(51, 51, 51);">下面的命令可以清理掉所有处于终止状态的容器。</font>

```plain
docker container prune
```

### <font style="color:rgb(51, 51, 51);">运行一个 web 应用</font>
<font style="color:rgb(51, 51, 51);">我们将在docker容器中运行一个 Python Flask 应用来运行一个web应用。</font>

```plain
 # 载入镜像
docker pull training/webapp 
#后台运行
docker run -d -P training/webapp python app.py
```

<font style="color:rgb(51, 51, 51);">参数说明:</font>

+ **<font style="color:rgb(51, 51, 51);">-d:</font>**<font style="color:rgb(51, 51, 51);">让容器在后台运行。</font>
+ **<font style="color:rgb(51, 51, 51);">-P:</font>**<font style="color:rgb(51, 51, 51);">将容器内部使用的网络端口随机映射到我们使用的主机上。</font>

### <font style="color:rgb(51, 51, 51);">查看 WEB 应用容器</font>
```plain
#查看正在运行的docker
docker ps
```

<font style="color:rgb(51, 51, 51);">这里多了端口信息。</font>

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651072274859-ef28ec7c-c0e6-4d86-a389-36deb063ee31.png)

<font style="color:rgb(51, 51, 51);">Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 </font>49153<font style="color:rgb(51, 51, 51);">上。</font>

<font style="color:rgb(51, 51, 51);">这时我们可以通过浏览器访问WEB应用</font>

**<font style="color:rgb(51, 51, 51);">访问之前 开启防火墙和云服务器安全组</font>**

**<font style="color:rgb(51, 51, 51);"></font>**

<font style="color:rgb(51, 51, 51);">我们也可以通过 -p 参数来设置不一样的端口：容器内部的 5000 端口映射到我们本地主机的 5000 端口上。</font>

```plain
docker run -d -p 5000:5000 training/webapp python app.py
```

### <font style="color:rgb(51, 51, 51);">网络端口的快捷方式</font>
<font style="color:rgb(51, 51, 51);">通过</font><font style="color:rgb(51, 51, 51);"> </font>**<font style="color:rgb(51, 51, 51);">docker ps</font>**<font style="color:rgb(51, 51, 51);"> 命令可以查看到容器的端口映射，</font>**<font style="color:rgb(51, 51, 51);">docker</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">还提供了另一个快捷方式</font><font style="color:rgb(51, 51, 51);"> </font>**<font style="color:rgb(51, 51, 51);">docker port</font>**<font style="color:rgb(51, 51, 51);">，使用 </font>**<font style="color:rgb(51, 51, 51);">docker port</font>**<font style="color:rgb(51, 51, 51);"> 可以查看指定 （ID 或者名字）容器的某个确定端口映射到宿主机的端口号。</font>

<font style="color:rgb(51, 51, 51);">上面我们创建的 web 应用容器 ID 为 </font>**5c8a4cfe1d25**<font style="color:rgb(51, 51, 51);">名字为 </font>**vigorous_gould**<font style="color:rgb(51, 51, 51);">。</font>

```plain
#指定容器ID
docker port 5c8a4cfe1d25
#指定容器name
docker port 5c8a4cfe1d25
```

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651073763266-2a9c8d50-debe-4332-b7cb-46c0ec4c5312.png)

### <font style="color:rgb(51, 51, 51);">查看 WEB 应用程序日志</font>
<font style="color:rgb(51, 51, 51);">docker logs [ID或者名字] 可以查看容器内部的标准输出。</font>

```plain
#指定容器ID
docker logs 5c8a4cfe1d25
#指定容器name
docker logs 5c8a4cfe1d25
#-f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出。
docker logs -f 5c8a4cfe1d25
```

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651073838529-37392c78-f8ad-4703-bff5-563c9ef528b9.png)

### <font style="color:rgb(51, 51, 51);">检查 WEB 应用程序</font>
<font style="color:rgb(51, 51, 51);">使用 </font>**<font style="color:rgb(51, 51, 51);">docker inspect</font>**<font style="color:rgb(51, 51, 51);"> 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息</font>

```plain
#指定容器ID
docker inspect 5c8a4cfe1d25
#指定容器name
docker inspect 5c8a4cfe1d25
```

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651074042244-931affcf-a59a-49be-9db9-d1d64901fcc3.png)

### <font style="color:rgb(51, 51, 51);">停止 WEB 应用容器</font>
```plain
#指定容器ID
docker stop 5c8a4cfe1d25
#指定容器name
docker stop vigorous_gould
```

### <font style="color:rgb(51, 51, 51);">重启WEB应用容器</font>
<font style="color:rgb(51, 51, 51);">已经停止的容器，我们可以使用命令 docker start 来启动。</font>

```plain
#指定容器ID
docker start 5c8a4cfe1d25
#指定容器name
docker start vigorous_gould
```

<font style="color:rgb(51, 51, 51);">docker ps -l 查询最后一次创建的容器：</font>

### <font style="color:rgb(51, 51, 51);">移除WEB应用容器</font>
<font style="color:rgb(51, 51, 51);">我们可以使用 docker rm 命令来删除不需要的容器</font>

<font style="color:rgb(51, 51, 51);"></font>

```plain
#先停止容器
docker stop 5c8a4cfe1d25
#指定容器ID
docker rm 5c8a4cfe1d25
#指定容器name
docker rm vigorous_gould
```

<font style="color:rgb(51, 51, 51);">删除容器时，容器必须是停止状态，否则会报如下错误</font>

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651074368890-0704aab3-6222-4dda-b8b2-b25ae768bdd8.png)

## 镜像的使用
<font style="color:rgb(51, 51, 51);">当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</font>

+ <font style="color:rgb(51, 51, 51);">1、管理和使用本地 Docker 主机镜像</font>
+ <font style="color:rgb(51, 51, 51);">2、创建镜像</font>

### <font style="color:rgb(51, 51, 51);">列出镜像列表</font>
```plain
docker images
```

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651074502560-f9fed62a-ae80-41c0-b3e1-6233ece1b065.png)

<font style="color:rgb(51, 51, 51);">各个选项说明:</font>

+ **<font style="color:rgb(51, 51, 51);">REPOSITORY：</font>**<font style="color:rgb(51, 51, 51);">表示镜像的仓库源</font>
+ **<font style="color:rgb(51, 51, 51);">TAG：</font>**<font style="color:rgb(51, 51, 51);">镜像的标签</font>
+ **<font style="color:rgb(51, 51, 51);">IMAGE ID：</font>**<font style="color:rgb(51, 51, 51);">镜像ID</font>
+ **<font style="color:rgb(51, 51, 51);">CREATED：</font>**<font style="color:rgb(51, 51, 51);">镜像创建时间</font>
+ **<font style="color:rgb(51, 51, 51);">SIZE：</font>**<font style="color:rgb(51, 51, 51);">镜像大小</font>

<font style="color:rgb(51, 51, 51);">同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</font>

<font style="color:rgb(51, 51, 51);">所以，我们如果要使用版本为15.10的ubuntu系统镜像来运行容器时，命令如下：</font>

```plain
docker run -t -i ubuntu:15.10 /bin/bash 
```

<font style="color:rgb(51, 51, 51);">参数说明：</font>

+ **<font style="color:rgb(51, 51, 51);">-i</font>**<font style="color:rgb(51, 51, 51);">: 交互式操作。</font>
+ **<font style="color:rgb(51, 51, 51);">-t</font>**<font style="color:rgb(51, 51, 51);">: 终端。</font>
+ **<font style="color:rgb(51, 51, 51);">ubuntu:15.10</font>**<font style="color:rgb(51, 51, 51);">: 这是指用 ubuntu 15.10 版本镜像为基础来启动容器。</font>
+ **<font style="color:rgb(51, 51, 51);">/bin/bash</font>**<font style="color:rgb(51, 51, 51);">：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</font>

<font style="color:rgb(51, 51, 51);">如果要使用版本为 14.04 的 ubuntu 系统镜像来运行容器时，命令如下：</font>

```plain
docker run -t -i ubuntu:14.04 /bin/bash 
```

### <font style="color:rgb(51, 51, 51);">获取一个新的镜像</font>
<font style="color:rgb(51, 51, 51);">当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</font>

```plain
docker pull ubuntu:13.10
```

### <font style="color:rgb(51, 51, 51);">查找镜像</font>
<font style="color:rgb(51, 51, 51);">我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。</font>

```plain
docker search httpd
docker search training/webapp
```

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651074855963-a6d9bd69-1ae6-462e-a039-1d609f470709.png)

**<font style="color:rgb(51, 51, 51);">NAME:</font>****<font style="color:rgb(51, 51, 51);"> </font>**<font style="color:rgb(51, 51, 51);">镜像仓库源的名称</font>

**<font style="color:rgb(51, 51, 51);">DESCRIPTION:</font>****<font style="color:rgb(51, 51, 51);"> </font>**<font style="color:rgb(51, 51, 51);">镜像的描述</font>

**<font style="color:rgb(51, 51, 51);">OFFICIAL:</font>****<font style="color:rgb(51, 51, 51);"> </font>**<font style="color:rgb(51, 51, 51);">是否 docker 官方发布</font>

**<font style="color:rgb(51, 51, 51);">stars:</font>****<font style="color:rgb(51, 51, 51);"> </font>**<font style="color:rgb(51, 51, 51);">类似 Github 里面的 star，表示点赞、喜欢的意思。</font>

**<font style="color:rgb(51, 51, 51);">AUTOMATED: </font>**<font style="color:rgb(51, 51, 51);">自动构建。</font>

### <font style="color:rgb(51, 51, 51);">拖取镜像</font>
<font style="color:rgb(51, 51, 51);">使用命令 docker pull 来下载镜像</font>

```plain
docker pull httpd
#下载完成之后运行镜像
docker run httpd
```

### <font style="color:rgb(51, 51, 51);">删除镜像</font>
<font style="color:rgb(51, 51, 51);">镜像删除使用 </font>**<font style="color:rgb(51, 51, 51);">docker rmi</font>**<font style="color:rgb(51, 51, 51);"> 命令，删除 hello-world 镜像</font>

```plain
docker rmi hello-world
```

### <font style="color:rgb(51, 51, 51);">创建镜像</font>
<font style="color:rgb(51, 51, 51);">当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。</font>

+ <font style="color:rgb(51, 51, 51);">1、从已经创建的容器中更新镜像，并且提交这个镜像</font>
+ <font style="color:rgb(51, 51, 51);">2、使用 Dockerfile 指令来创建一个新的镜像</font>

### <font style="color:rgb(51, 51, 51);">更新镜像</font>
<font style="color:rgb(51, 51, 51);">更新镜像之前，我们需要使用镜像来创建一个容器，</font><font style="color:rgb(51, 51, 51);">在运行的容器内使用 </font>**<font style="color:rgb(51, 51, 51);">apt-get update</font>**<font style="color:rgb(51, 51, 51);"> 命令进行更新，在完成操作之后，输入 exit 命令来退出这个容器。</font>

```plain
#镜像来创建一个容器
docker run -t -i ubuntu:15.10 /bin/bash

#容器内使用
root@a996acb76ad9:/#apt-get update
```

<font style="color:rgb(51, 51, 51);">此时 ID 为 </font>a996acb76ad9 <font style="color:rgb(51, 51, 51);">的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本。</font>

```plain
docker commit -m="has update" -a="runoob" a996acb76ad9 runoob/ubuntu:v2
```

<font style="color:rgb(51, 51, 51);">各个参数说明：</font>

+ **<font style="color:rgb(51, 51, 51);">-m:</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">提交的描述信息</font>
+ **<font style="color:rgb(51, 51, 51);">-a:</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">指定镜像作者</font>
+ **<font style="color:rgb(51, 51, 51);">e218edb10161：</font>**<font style="color:rgb(51, 51, 51);">容器 ID</font>
+ **<font style="color:rgb(51, 51, 51);">runoob/ubuntu:v2:</font>**<font style="color:rgb(51, 51, 51);"> 指定要创建的目标镜像名</font>

<font style="color:rgb(51, 51, 51);">我们可以使用 </font>**<font style="color:rgb(51, 51, 51);">docker images</font>**<font style="color:rgb(51, 51, 51);"> 命令来查看我们的新镜像 </font>**<font style="color:rgb(51, 51, 51);">runoob/ubuntu:v2</font>**<font style="color:rgb(51, 51, 51);">：</font>

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651075552153-74fd17a7-3a7a-4c70-a67e-84bbcc76cfea.png)

<font style="color:rgb(51, 51, 51);">使用我们的新镜像 </font>**<font style="color:rgb(51, 51, 51);">runoob/ubuntu</font>**<font style="color:rgb(51, 51, 51);"> 来启动一个容器</font>

```plain
docker run -t -i runoob/ubuntu:v2 /bin/bash
```

### <font style="color:rgb(51, 51, 51);">构建镜像</font>
<font style="color:rgb(51, 51, 51);">我们使用命令 </font>**<font style="color:rgb(51, 51, 51);">docker build</font>**<font style="color:rgb(51, 51, 51);"> ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。</font>

参考 <font style="color:rgb(0, 0, 0);"> 【Docker Dockerfile】</font>

```plain
#构建镜像
docker build -t nginx:v3 /data/Dockerfile
```

<font style="color:rgb(51, 51, 51);">参数说明：</font>

+ **<font style="color:rgb(51, 51, 51);">-t</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">：指定要创建的目标镜像名</font>
+ **<font style="color:rgb(51, 51, 51);">.</font>**<font style="color:rgb(51, 51, 51);"> ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</font>



使用新的镜像来构建容器

```plain
docker run -t -i nginx:v3  /bin/bash
```

进入容器，有我们创建的文件

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651080107498-d8db253f-e672-4c6c-bed3-c82546a54055.png)

### <font style="color:rgb(51, 51, 51);">设置镜像标签（复制）</font>
<font style="color:rgb(51, 51, 51);">我们可以使用 docker tag 命令，为镜像添加一个新的标签。</font>

```plain
docker tag eeb6ee3f44bd centos:dev
```

<font style="color:rgb(51, 51, 51);">docker tag 镜像ID，这里是 860c279d2fec ,用户名称、镜像源名(repository name)和新的标签名(tag)。</font>

<font style="color:rgb(51, 51, 51);">使用 docker images 命令可以看到，ID为860c279d2fec的镜像多一个标签。</font>

<font style="color:rgb(51, 51, 51);"></font>

## <font style="color:rgb(0, 0, 0);">Docker Dockerfile</font>
<font style="color:rgb(51, 51, 51);">Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</font>

### <font style="color:rgb(51, 51, 51);">举例 nginx 镜像</font>
<font style="color:rgb(51, 51, 51);">在一个空目录下，新建一个名为 Dockerfile 文件，并在文件内添加以下内容：</font>

```plain
#创建一个空目录,写入内容到
mkdir /data/Dockerfile

vim /data/Dockerfile/Dockerfile

FROM centos:7
RUN mkdir /data
RUN echo '这是一个本地构建的nginx镜像' > /data/nginx_docker

#在 Dockerfile 文件的存放目录下，执行构建动作。
cd /data/Dockerfile/
docker build -t nginx:v3 .

#或者使用绝对路径 docker build -t nginx:v3 /data/Dockerfile

#查看镜像
docker image
```

**<font style="color:rgb(51, 51, 51);">注：最后的 </font>****<font style="color:rgb(51, 51, 51);background-color:rgb(236, 234, 230);">.</font>****<font style="color:rgb(51, 51, 51);"> 代表本次执行的上下文路径,也可以用绝对路径</font>**

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651077765241-f6436dee-e384-4a68-96f6-d3f9eca255a8.png)

### 参数详解
具体其余参数参考 [https://www.runoob.com/docker/docker-dockerfile.html](https://www.runoob.com/docker/docker-dockerfile.html)

参数

+ FROM  指定基础镜像
+ MAINTAINER 指定维护者信息，可以没有
+ LABLE      描述，标签， 和MAINTAINER的区别是可以支持多行描述
+ RUN  在命令前面加上RUN即可
+ ADD  拷贝文件到容器里面，自动解压tar文件
+ WORKDIR 设置当前工作目录
+ VOLUME 设置卷，挂载主机目录
+ EXPOSE 指定对外的端口(-P 随机端口)
+ CMD 指定容器启动后的要干的事情（比如shell脚本，容易替换）
+ dockerfile其他指令： 
+ COPY 复制文件（不会解压）rootfs.tar.gz
+ ENV  环境变量
+ ENTRYPOINT  容器启动后执行的命令（无法被替换，启容器的时候指定的命令，会被当成参数）

## <font style="color:rgb(0, 0, 0);">Docker 容器连接</font>
<font style="color:rgb(51, 51, 51);">容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 </font>**<font style="color:rgb(51, 51, 51);background-color:rgb(236, 234, 230);">-P</font>**<font style="color:rgb(51, 51, 51);"> 或 </font>**<font style="color:rgb(51, 51, 51);background-color:rgb(236, 234, 230);">-p</font>**<font style="color:rgb(51, 51, 51);"> 参数来指定端口映射。</font>

### <font style="color:rgb(51, 51, 51);">网络端口映射</font>
<font style="color:rgb(51, 51, 51);">我们创建了一个 python 应用的容器。</font>

```plain
docker run -d -P training/webapp python app.py
```

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651072274859-ef28ec7c-c0e6-4d86-a389-36deb063ee31.png)

<font style="color:rgb(51, 51, 51);">我们也可以使用</font><font style="color:rgb(51, 51, 51);"> </font>**<font style="color:rgb(51, 51, 51);">-p</font>**<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">标识来指定容器端口绑定到主机端口。</font>

<font style="color:rgb(51, 51, 51);">两种方式的区别是:</font>

+ **<font style="color:rgb(51, 51, 51);">-P :</font>**<font style="color:rgb(51, 51, 51);">是容器内部端口</font>**<font style="color:rgb(51, 51, 51);">随机</font>**<font style="color:rgb(51, 51, 51);">映射到主机的端口。</font>
+ **<font style="color:rgb(51, 51, 51);">-p : </font>**<font style="color:rgb(51, 51, 51);">是容器内部端口绑定到</font>**<font style="color:rgb(51, 51, 51);">指定</font>**<font style="color:rgb(51, 51, 51);">的主机端口。</font>



### <font style="color:rgb(51, 51, 51);">绑定到指定的主机端口</font>
```plain
docker run -d -p 5000:5000 training/webapp python app.py
```

### <font style="color:rgb(51, 51, 51);">绑定的网络地址</font>
<font style="color:rgb(51, 51, 51);">比如绑定 127.0.0.1。</font>

```plain
docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py
```

<font style="color:rgb(51, 51, 51);">这样我们就可以通过访问 127.0.0.1:5001 来访问容器的 5000 端口</font>

### <font style="color:rgb(51, 51, 51);"> tcp 端口绑定 UDP 端口</font>
```plain
 docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py
```

### <font style="color:rgb(51, 51, 51);">Docker 容器互联</font>
<font style="color:rgb(51, 51, 51);">端口映射并不是唯一把 docker 连接到另一个容器的方法。</font>

<font style="color:rgb(51, 51, 51);">docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。</font>

<font style="color:rgb(51, 51, 51);">docker 连接会创建一个父子关系，其中父容器可以看到子容器的信息。</font>

#### <font style="color:rgb(51, 51, 51);">容器命名</font>
<font style="color:rgb(51, 51, 51);">当我们创建一个容器的时候，docker 会自动对它进行命名。另外，我们也可以使用 </font>**<font style="color:rgb(51, 51, 51);">--name</font>**<font style="color:rgb(51, 51, 51);"> 标识来命名容器，例如：</font>

```plain
 docker run -d -P --name runoob training/webapp python app.py
 #查看容器
 docker ps
```

#### <font style="color:rgb(51, 51, 51);">新建网络</font>
```plain
docker network create -d bridge test-net
```

<font style="color:rgb(51, 51, 51);">参数说明：</font>

**<font style="color:rgb(51, 51, 51);">-d</font>**<font style="color:rgb(51, 51, 51);">：参数指定 Docker 网络类型，有 bridge、overlay。</font>

<font style="color:rgb(51, 51, 51);">其中 overlay 网络类型用于 Swarm mode，在本小节中你可以忽略它。</font>

#### <font style="color:rgb(51, 51, 51);">连接容器</font>
<font style="color:rgb(51, 51, 51);">运行一个容器并连接到新建的 test-net 网络:</font>

```plain
 docker run -itd --name test1 --network test-net ubuntu /bin/bash
```

<font style="color:rgb(51, 51, 51);">打开新的终端，再运行一个容器并加入到 test-net 网络:</font>

```plain
 docker run -itd --name test2 --network test-net ubuntu /bin/bash
```

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651128727264-6dd74eab-d5c7-4095-a512-f3a3f2e2b8b3.png)

<font style="color:rgb(51, 51, 51);">下面通过 ping 来证明 test1 容器和 test2 容器建立了互联关系。</font>

<font style="color:rgb(51, 51, 51);">如果 test1、test2 容器内中无 ping 命令，则在容器内执行以下命令安装 ping（即学即用：可以在一个容器里安装好，提交容器到镜像，在以新的镜像重新运行以上俩个容器）。</font>

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651129201196-885b55a5-31b1-4e72-9783-8ca95a8cabf9.png)

<font style="color:rgb(51, 51, 51);">如果你有多个容器之间需要互相连接，推荐使用 Docker Compose，后面会介绍</font>

#### <font style="color:rgb(51, 51, 51);">配置 DNS（配置文件）</font>
**json文件配置**

<font style="color:rgb(51, 51, 51);">我们可以在宿主机的 /etc/docker/daemon.json 文件中增加以下内容来设置全部容器的 DNS：</font>

<font style="color:rgb(51, 51, 51);"></font>

```plain
#加入以下文件到daemon.json
{
 "registry-mirrors": ["https://nsodgxr5.mirror.aliyuncs.com"],
 "dns" : ["114.114.114.114","8.8.8.8"]
}

#重启docker
systemctl restart docker

#输出容器的 DNS 信息
docker run -it --rm  ubuntu  cat etc/resolv.conf
```

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651130179079-48a6de44-bcbe-4124-ba1e-0fc5c4cf639c.png)

**<font style="color:rgb(51, 51, 51);">手动指定容器的配置</font>**

**<font style="color:#E8323C;">如果在容器启动时没有指定 --dns 和 --dns-search，Docker 会默认用宿主主机上的 /etc/resolv.conf 来配置容器的 DNS。</font>**

```plain
docker run -it --rm -h host_ubuntu  --dns=114.114.114.115 --dns-search=test.com ubuntu
```

<font style="color:rgb(51, 51, 51);">数说明：</font>

**<font style="color:rgb(51, 51, 51);">--rm</font>**<font style="color:rgb(51, 51, 51);">：容器退出时自动清理容器内部的文件系统。</font>

**<font style="color:rgb(51, 51, 51);">-h HOSTNAME 或者 --hostname=HOSTNAME</font>**<font style="color:rgb(51, 51, 51);">： 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。</font>

**<font style="color:rgb(51, 51, 51);">--dns=IP_ADDRESS</font>**<font style="color:rgb(51, 51, 51);">： 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</font>

**<font style="color:rgb(51, 51, 51);">--dns-search=DOMAIN</font>**<font style="color:rgb(51, 51, 51);">： 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。</font>

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651130512642-1a3c868e-1bd1-478f-ab58-6ac7e587eaaf.png)



```plain
docker- daemon.json各配置详解
{
    "allow-nondistributable-artifacts": [], #不对外分发的产品提交的registry仓库
    “api -cors-header”: "" ,         #在引擎API中设置CORS标头
    “authorization - plugins”:[],    #要加载的授权插件
    “bridge”: "" ,           #将容器附加到网桥
    “cgroup -parent”: "" ,           #为所有容器设置父cgroup
    “cluster -store”: "" ,           #分布式存储后端的URL
    “cluster -store- opts”:{},       #设置集群存储选项（默认map []）
    “cluster -advertise”: "" ,       #要通告的地址或接口名称
    “data -root”: " /var/lib/docker " ,           #Docker运行时使用的根路径，默认/var/lib/ docker
    “debug”:  true ,           #启用调试模式，启用后，可以看到很多的启动信息。默认false
    “default -gateway”: "" ,          #容器默认网关IPv4地址
    “default -gateway-v6”: "" ,       #容器默认网关IPv6地址
    “default - runtime”:“runc”,       #容器的默认OCI运行时（默认为“ runc”）
    “default - ulimits”:{},           #容器的默认ulimit（默认[]）
    “dns”: [],       #设定容器DNS的地址，在容器的 /etc/ resolv.conf文件中可查看。
    “dns -opts”: [],                  #容器 /etc/ resolv.conf 文件，其他设置
    “dns - search”: [],         #设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的 主机时，DNS不仅搜索host，还会搜索host.example.com 。 注意：如果不设置， Docker 会默认用主机上的  /etc/ resolv.conf 来配置容器。
    “exec - opts”: [],          #运行时执行选项
    “exec -root”: "" ,          #执行状态文件的根目录（默认为’/var/run/ docker‘）
    “fixed -cidr”: "" ,         #固定IP的IPv4子网
    “fixed -cidr-v6”: "" ,      #固定IP的IPv6子网
    “group”: “”,           #UNIX套接字的组（默认为“docker”）
    "graph":"/var/lib/docker",  #已废弃，使用data-root代替，查看docker版本
    “hosts”: [],           #设置容器hosts
    “icc”:  false ,        #启用容器间通信（默认为true）
    “insecure-registries”: [“ 120.123 . 122.123 : 12312 ”],           #设置私有仓库地址可以设为http
    “ip”:“ 0.0 . 0.0 ”,    #绑定容器端口时的默认IP（默认0. 0.0 . 0 ）
    “iptables”:  false ,   #启用iptables规则添加（默认为true）
    “ipv6”:  false ,       #启用IPv6网络
    “ip -forward”:  false ,       #默认true, 启用 net.ipv4.ip_forward ,进入容器后使用 sysctl -a |  grepnet.ipv4.ip_forward 查看
    “ip -masq”: false ,           #启用IP伪装（默认为true）
    “labels”:[“nodeName =node- 121 ”],           #docker主机的标签，很实用的功能,例如定义：–label nodeName=host- 121 
    “live -restore”:  true ,     #在容器仍在运行时启用docker的实时还原
    “log -driver”: "" ,          #容器日志的默认驱动程序（默认为“ json- file ”）
    “log -level”: "" ,           #设置日志记录级别（“调试”，“信息”，“警告”，“错误”，“致命”）（默认为“信息”）
    “max -concurrent-downloads”: 3 ,         #设置每个请求的最大并发下载量（默认为3）
    “max -concurrent-uploads”: 5 ,           #设置每次推送的最大同时上传数（默认为5）
    “mtu”:  0 ,              #设置容器网络MTU
    “oom -score-adjust”:- 500 ,          #设置守护程序的oom_score_adj（默认值为- 500 ）
    “pidfile”: “”,           #Docker守护进程的PID文件
    “raw -logs”:  false ,           #原始日志、全时间戳机制
    “registry -mirrors”: [“https: // 192.168.2.23:89”],   #设置镜像加速地址
    “selinux -enabled”:  false ,    #默认  false ，启用selinux支持
    “storage -driver”: "" ,         #要使用的存储驱动程序
    “swarm -default-advertise-addr”: "" ,          #设置默认地址或群集广告地址的接口
    “tls”:  true ,           #默认  false , 启动TLS认证开关
    “tlscacert”: “”,         #默认  ~/.docker/ ca.pem，通过CA认证过的的certificate文件路径
    “tlscert”: “”,           #默认  ~/.docker/ cert.pem ，TLS的certificate文件路径
    “tlskey”: “”,            #默认 ~/.docker/ key.pem，TLS的key文件路径
    “tlsverify”:true ,           #默认false，使用TLS并做后台进程与客户端通讯的验证
    “userland -proxy”:false ,    #使用userland代理进行环回流量（默认为true）
    “userns -remap”: "" ,        #用户名称空间的用户/ 组设置
    “bip”:“ 192.168 . 88.0 / 22 ”,          #指定网桥IP
    “storage - opts”: {
    “overlay2.override_kernel_check = true ”,
    “overlay2.size = 15G”
    },         #存储驱动程序选项
 "labels":["nodeName=node-121"],        #docker主机的标签
 "live-restore": true,
 "log-driver":"",
 "log-level":"",
 "log-opts": {},
 "max-concurrent-downloads":3,
 "max-concurrent-uploads":5,
 "mtu": 0,
 "oom-score-adjust":-500,
 
“log - opts”: {
    “max - file ”: “ 3 ”,
    “max - size”: “10m”,
    },         #容器默认日志驱动程序选项
    “iptables”:  false          #启用iptables规则添加（默认为true）
}
```

## <font style="color:rgb(0, 0, 0);">Docker 仓库管理</font>
<font style="color:rgb(51, 51, 51);">仓库（Repository）是集中存放镜像的地方。以下介绍一下 </font>[Docker Hub](https://hub.docker.com/)<font style="color:rgb(51, 51, 51);">。当然不止 docker hub，只是远程的服务商不一样，操作都是一样的。</font>

Docker仓库, 类似于yum仓库, 是用来保存镜像的仓库. 为了方便管理和使用Docker镜像, 可以将镜像集中保存至Docker仓库中, 将制作好的镜像推送(push)到仓库之种保存, 在需要镜像时, 从仓局中拉取(pull)镜像即可.

Docker仓库分为公有云仓库和私有云仓库:

### 官方<font style="color:rgb(51, 51, 51);">Docker Hub</font>
<font style="color:rgb(64, 64, 64);">将自制的镜像上传至docker仓库: </font>[https://hub.docker.com](https://links.jianshu.com/go?to=https%3A%2F%2Fhub.docker.com)

<font style="color:rgb(51, 51, 51);">免费注册一个 Docker 账号</font>

### <font style="color:rgb(51, 51, 51);">登录和退出</font>
<font style="color:rgb(51, 51, 51);">登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像。</font>

<font style="color:rgb(64, 64, 64);">上传镜像前, 需要执行docker login命令登录, 登录后生成~/.docker/config.json文件保存验证信息</font>

 docker logout  清空 <font style="color:rgb(64, 64, 64);">~/.docker/config.json里面的验证信息</font>

```plain
 #登录  输入账号和密码
 docker login
 
 #使用 docker pull 将官方 ubuntu 镜像下载到本地
 docker pull ubuntu 
 
 #退出
 docker logout
```

### 推送镜像
<font style="color:rgb(51, 51, 51);">用户登录后，可以通过 docker push 命令将自己的镜像推送到 Docker Hub。</font>

<font style="color:rgb(0, 0, 0);">docker push username</font><font style="color:rgb(102, 102, 0);">/</font>**<font style="color:rgb(51, 51, 51);">REPOSITORY:TAG</font>**

<font style="color:rgb(51, 51, 51);">各个选项说明:</font>

+ <font style="color:rgb(0, 0, 0);">username：</font><font style="color:rgb(51, 51, 51);"> Docker 账号用户名</font>
+ **<font style="color:rgb(51, 51, 51);">REPOSITORY：</font>**<font style="color:rgb(51, 51, 51);">表示镜像的仓库源</font>
+ **<font style="color:rgb(51, 51, 51);">TAG：</font>**<font style="color:rgb(51, 51, 51);">镜像的标签</font>

```plain
#查看本地镜像   这里以 hello-world 为例
docker images # 或者 docker image ls

#复制本地的镜像  这里以hello-world 为例
docker tag feb5d9fea6a5 hashiqidocker/helloworld:dev

#推送自己的镜像到Docker Hub
docker push hashiqidocker/helloworld:dev
#查询自己推送的镜像
docker search hashiqidocker/helloworld
```

### 查询自己推送的镜像
```plain
docker search username/helloworld
```

## <font style="color:rgb(0, 0, 0);">Docker Compose</font>
### <font style="color:rgb(51, 51, 51);">Compose 简介</font>
<font style="color:rgb(51, 51, 51);">Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</font>

<font style="color:rgb(51, 51, 51);"></font>

<font style="color:rgb(51, 51, 51);">YAML 是 "YAML Ain't a Markup Language"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是："Yet Another Markup Language"（仍是一种标记语言）。</font>

<font style="color:rgb(51, 51, 51);">YAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。</font>

<font style="color:rgb(51, 51, 51);">YAML 的配置文件后缀为 </font>**<font style="color:rgb(51, 51, 51);background-color:rgb(236, 234, 230);">.yml</font>**<font style="color:rgb(51, 51, 51);">，如：</font>**<font style="color:rgb(51, 51, 51);">runoob.yml</font>**<font style="color:rgb(51, 51, 51);"> 。</font>

### <font style="color:rgb(51, 51, 51);">Compose 安装</font>
<font style="color:rgb(51, 51, 51);">Linux 上我们可以从 Github 上下载它的二进制包来使用，最新发行的版本地址：</font>[https://github.com/docker/compose/releases](https://github.com/docker/compose/releases)<font style="color:rgb(51, 51, 51);">。</font>

<font style="color:rgb(51, 51, 51);">运行以下命令以下载 Docker Compose 的当前稳定版本：</font>

_**<font style="color:rgb(51, 51, 51);background-color:rgb(243, 247, 240);">Docker Compose 存放在 GitHub，不太稳定。</font>**_

```plain
sudo curl -L "https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
```

_**<font style="color:rgb(51, 51, 51);background-color:rgb(243, 247, 240);">高速安装 Docker Compose。</font>**_

```plain
#安装
curl -L https://get.daocloud.io/docker/compose/releases/download/v2.4.1/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose
#将可执行权限应用于二进制文件
sudo chmod +x /usr/local/bin/docker-compose
#创建软链
sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
#测试是否安装成功  输出：  Docker Compose version v2.4.1
docker-compose --version
```

<font style="color:rgb(51, 51, 51);">要安装其他版本的 Compose，请替换 v2.2.2。</font>

### <font style="color:rgb(51, 51, 51);">使用步骤</font>
<font style="color:rgb(51, 51, 51);">Compose 使用的三个步骤：</font>

+ <font style="color:rgb(51, 51, 51);">使用 Dockerfile 定义应用程序的环境。</font>
+ <font style="color:rgb(51, 51, 51);">使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</font>
+ <font style="color:rgb(51, 51, 51);">最后，执行 docker-compose up 命令来启动并运行整个应用程序。</font>

#### <font style="color:rgb(51, 51, 51);">1、准备</font>
<font style="color:rgb(51, 51, 51);">创建一个测试目录</font>

<font style="color:rgb(51, 51, 51);">此示例中，redis 是应用程序网络上的 redis 容器的主机名，该主机使用的端口为 6379。</font>

```plain
mkdir /data/composetest
cd /data/composetest
#在测试目录中创建一个名为 app.py 的文件,内容如下

import time
import redis
from flask import Flask

app = Flask(__name__)
cache = redis.Redis(host='redis', port=6379)


def get_hit_count():
    retries = 5
    while True:
        try:
            return cache.incr('hits')
        except redis.exceptions.ConnectionError as exc:
            if retries == 0:
                raise exc
            retries -= 1
            time.sleep(0.5)


@app.route('/')
def hello():
    count = get_hit_count()
    return 'Hello World! I have been seen {} times.\n'.format(count)

```

<font style="color:rgb(51, 51, 51);">在 composetest 目录中创建另一个名为 </font>**<font style="color:rgb(51, 51, 51);background-color:rgb(236, 234, 230);">requirements.txt</font>**<font style="color:rgb(51, 51, 51);"> 的文件，内容如下：</font>

```plain
cd /data/composetest
vim requirements.txt
#内容如下

flask
redis
```

#### <font style="color:rgb(51, 51, 51);">2、创建 Dockerfile 文件</font>
<font style="color:rgb(51, 51, 51);">在 composetest 目录中，创建一个名为 </font>**<font style="color:rgb(51, 51, 51);background-color:rgb(236, 234, 230);">Dockerfile</font>**<font style="color:rgb(51, 51, 51);"> 的文件</font>

```plain
cd /data/composetest
vim Dockerfile
#内容如下

FROM python:3.7-alpine
WORKDIR /code
ENV FLASK_APP app.py
ENV FLASK_RUN_HOST 0.0.0.0
RUN apk add --no-cache gcc musl-dev linux-headers
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt
COPY . .
CMD ["flask", "run"]
```

**<font style="color:rgb(51, 51, 51);">Dockerfile 内容解释：</font>**

+ **<font style="color:rgb(51, 51, 51);">FROM python:3.7-alpine</font>**<font style="color:rgb(51, 51, 51);">: 从 Python 3.7 映像开始构建镜像。</font>
+ **<font style="color:rgb(51, 51, 51);">WORKDIR /code</font>**<font style="color:rgb(51, 51, 51);">: 将工作目录设置为 /code。</font>
+ <font style="color:rgb(0, 0, 0);">ENV FLASK_APP app</font><font style="color:rgb(102, 102, 0);">.</font><font style="color:rgb(0, 0, 0);">py ENV FLASK_RUN_HOST </font><font style="color:rgb(0, 102, 102);">0.0</font><font style="color:rgb(102, 102, 0);">.</font><font style="color:rgb(0, 102, 102);">0.0</font><font style="color:rgb(51, 51, 51);">设置 flask 命令使用的环境变量。</font>
+ **<font style="color:rgb(51, 51, 51);">RUN apk add --no-cache gcc musl-dev linux-headers</font>**<font style="color:rgb(51, 51, 51);">: 安装 gcc，以便诸如 MarkupSafe 和 SQLAlchemy 之类的 Python 包可以编译加速。</font>
+ <font style="color:rgb(0, 0, 0);">COPY requirements</font><font style="color:rgb(102, 102, 0);">.</font><font style="color:rgb(0, 0, 0);">txt requirements</font><font style="color:rgb(102, 102, 0);">.</font><font style="color:rgb(0, 0, 0);">txt RUN pip install </font><font style="color:rgb(102, 102, 0);">-</font><font style="color:rgb(0, 0, 0);">r requirements</font><font style="color:rgb(102, 102, 0);">.</font><font style="color:rgb(0, 0, 0);">txt</font><font style="color:rgb(51, 51, 51);">复制 requirements.txt 并安装 Python 依赖项。</font>
+ **<font style="color:rgb(51, 51, 51);">COPY . .</font>**<font style="color:rgb(51, 51, 51);">: 将 . 项目中的当前目录复制到 . 镜像中的工作目录。</font>
+ **<font style="color:rgb(51, 51, 51);">CMD ["flask", "run"]</font>**<font style="color:rgb(51, 51, 51);">: 容器提供默认的执行命令为：flask run。</font>

#### <font style="color:rgb(51, 51, 51);">3、创建 docker-compose.yml</font>
<font style="color:rgb(51, 51, 51);">在测试目录中创建一个名为 docker-compose.yml 的文件</font>

```plain
cd /data/composetest
vim docker-compose.yml
#内容如下

# yaml 配置
version: '3'
services:
  web:
    build: .
    ports:
     - "5000:5000"
  redis:
    image: "redis:alpine"
```

<font style="color:rgb(51, 51, 51);">该 Compose 文件定义了两个服务：web 和 redis。</font>

+ **<font style="color:rgb(51, 51, 51);">web</font>**<font style="color:rgb(51, 51, 51);">：该 web 服务使用从 Dockerfile 当前目录中构建的镜像。然后，它将容器和主机绑定到暴露的端口 5000。此示例服务使用 Flask Web 服务器的默认端口 5000 。</font>
+ **<font style="color:rgb(51, 51, 51);">redis</font>**<font style="color:rgb(51, 51, 51);">：该 redis 服务使用 Docker Hub 的公共 Redis 映像。</font>
+ <font style="color:rgb(51, 51, 51);"></font>

<font style="color:rgb(51, 51, 51);">yml 配置指令参考</font>

+ <font style="color:rgb(51, 51, 51);">version:指定本 yml 依从的 compose 哪个版本制定的。</font>
+ <font style="color:rgb(51, 51, 51);">build:</font><font style="color:rgb(51, 51, 51);">指定为构建镜像上下文路径：</font>

<font style="color:rgb(51, 51, 51);">例如 webapp 服务，指定为从上下文路径 ./dir/Dockerfile 所构建的镜像：</font>

+ <font style="color:rgb(51, 51, 51);">context：上下文路径。</font>
+ <font style="color:rgb(51, 51, 51);">dockerfile：指定构建镜像的 Dockerfile 文件名。</font>
+ <font style="color:rgb(51, 51, 51);">args：添加构建参数，这是只能在构建过程中访问的环境变量。</font>
+ <font style="color:rgb(51, 51, 51);">labels：设置构建镜像的标签。</font>
+ <font style="color:rgb(51, 51, 51);">target：多层构建，可以指定构建哪一层。</font>

<font style="color:rgb(51, 51, 51);"></font>



#### <font style="color:rgb(51, 51, 51);">4、使用 Compose 命令构建和运行您的应用</font>
```plain
#测试目录中启动
docker-compose up
#或者后台运行
docker-compose up -d
```

## <font style="color:rgb(0, 0, 0);">Docker Machine</font>
### <font style="color:rgb(51, 51, 51);">简介</font>
<font style="color:rgb(51, 51, 51);">Docker Machine 是一种可以让您在虚拟主机上安装 Docker 的工具，并可以使用 docker-machine 命令来管理主机。</font>

<font style="color:rgb(51, 51, 51);">Docker Machine 也可以集中管理所有的 docker 主机，比如快速的给 100 台服务器安装上 docker。</font>

<font style="color:rgb(51, 51, 51);">Docker Machine 管理的虚拟主机可以是机上的，也可以是云供应商，如阿里云，腾讯云，AWS，或 DigitalOcean。</font>

<font style="color:rgb(51, 51, 51);">使用 docker-machine 命令，您可以启动，检查，停止和重新启动托管主机，也可以升级 Docker 客户端和守护程序，以及配置 Docker 客户端与您的主机进行通信。</font>

### <font style="color:rgb(51, 51, 51);">安装</font>
<font style="color:rgb(51, 51, 51);">安装 Docker Machine 之前你需要先安装 Docker。</font>

```plain
base=https://github.com/docker/machine/releases/download/v0.16.0 &&
  curl -L $base/docker-machine-$(uname -s)-$(uname -m) >/tmp/docker-machine &&
  sudo mv /tmp/docker-machine /usr/local/bin/docker-machine &&
  chmod +x /usr/local/bin/docker-machine
  
#刚才应该按照到 /usr/bin 下，也没关系，直接执行软连接
ln -s /usr/local/bin/docker-machine /usr/bin/docker-machine
```

如果上述下载很慢 

1、进入终端命令行模式，输入sudo vi /etc/hosts

2、输入i进入编辑命令，英文输入法输入G，vim编辑器跳到hosts文件的最后一行

3、用浏览器访问 IPAddress.com 使用 IP Lookup 工具获得github.com和github.global.ssl.fastly.net域名的ip地址

4、在vi打开的hosts文件中添加如下格式：

**<font style="color:rgb(102, 102, 102);">20.205.243.166</font>**<font style="color:rgb(51, 51, 51);"> </font>github.com

**<font style="color:rgb(102, 102, 102);background-color:rgb(250, 250, 250);">199.59.148.202</font>**  github.global.ssl.fastly.net

5、esc退出编辑模式，输入：wq，保存hosts文件，修改hosts结束

6、更新DNS缓存，输入 systemctl restart network

加速之后的速度

![](https://cdn.nlark.com/yuque/0/2022/png/12769034/1651139248129-b31734bd-6e0f-4c34-b33c-0adf0115546b.png)



<font style="color:rgb(51, 51, 51);">检测是否安装成功</font>

```plain
docker-machine version
```

### 使用
#### <font style="color:rgb(51, 51, 51);">1、列出可用的机器</font>
没有 **<font style="color:rgb(79, 79, 79);background-color:rgb(238, 240, 244);">  virtualbox 就按照  yum install  virtualbox</font>**

```plain
docker-machine ls
```

#### <font style="color:rgb(51, 51, 51);">2、创建机器</font>
<font style="color:rgb(51, 51, 51);">创建一台名为 test 的机器。</font>

```plain
docker-machine create --driver virtualbox test
```

#### 3.其余参考
[https://www.runoob.com/docker/docker-machine.html](https://www.runoob.com/docker/docker-machine.html)

## <font style="color:rgb(0, 0, 0);">Swarm 集群管理</font>
参考 [https://www.runoob.com/docker/docker-swarm.html](https://www.runoob.com/docker/docker-swarm.html)





